상속(inheritance)
- 객체 지향의 상속
  - 부모 클래스에 만들어진 필드, 메서드를 자식클래스가 물려받음
  - 부모의 생물학적 특성을 물려받는 유전과 유사
- 중복해서 쓸 일이없다.
- 상속을 통해 간결한 자식 클래스 작성
  - 동일한 특성을 재정의할 필요가 없어 자식 클래스가 간결해짐

상속의 장점
- 클래스의 간결화

클래스 관리 용이

소프트웨어의 생산성 향상

자바 상속의 특징
- 단일 상속만 가능
- 클래스의 다중 상속 지원하지 않음
- 상속 횟수 무제한
- 상속의 최상위 조상 클래스는 java.lang.Object 클래스
(모든 클래스는 자동으로 java.lang.Object를 상속받음)
(자바 컴파일러에 의해 자동으로 이루어짐)

호출 순서 = 자식(sub class)  - 부모(super class)
실행 순서 = 부모(super class) - 자식(sub class)

super()를 이용하여 명시적으로 슈퍼 클래스 생성자 선택
▶ super()
- 서브 클래스에서 명시적으로 슈퍼 클래스의 생성자 선택 호출
  ▶ super(parameter)
  ▶ 인자를 이용하여 슈퍼 클래스의 적당한 생성자 호출
  ▶ 반드시 서브 클래스 생성자 코드의 제일 첫 라인에 와야 함

super()이용하면 부모 클래스의 원하는 것을 가져와서 쓸 수 있음

03/30
업캐스팅 : 자식 클래스를 부모(super)클래스로 타입 변환
	 매우 큰 범주를 말하는 것
부모가 갖고 있는 멤버 생성자에만 접근이 가능하다

다운캐스팅 : 업캐스팅 된 걸 다시 원래 타입으로 변환

업캐스팅 된 레퍼런스로 객체의 타입 판단 어려움
instanceof 연산자
- 레퍼런스가 가리키는 객체의 타입 식별을 위해 사용

메서드 오버라이딩(상속 관계에서만 일어난다) -> 겉은 같고 속은 다르다
내부 코드만 다르고 이름, 리턴타입, 매개변수 타입 및 개수, 데이터 타입은 같아야한다.
: 슈퍼(부모) 클래스의 메서드를 서브(자식) 클래스에서 재정의
 - 슈퍼 클래스 메서드의 이름, 매개변수 타입 및 개수, 리턴 타입 등 모든 것 동일하게 작성
(내부 동작만 다름)

메서드 무시하기, 덮어쓰기로 번역되기도 함

동적 바인딩 발생
- 서브 클래스에 오버라이딩된 메서드가 무조건 실행되는 동적 바인딩

@Override // @

03/31
동적 바인딩 : 오버라이딩 된 녀석을 무조건 사용한다
재정의 된 녀석을 우선 순위로 따진다(super를 쓰지 않았다면)

정적 바인딩 
super를 이용해서 정적 바인딩해주면 된다.
super를 사용하면 부모 클래스와 자식 클래스 중 부모클래스의 것을 우선으로 한다.


